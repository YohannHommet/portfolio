name: ğŸš€ Deploy to Production

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging

env:
  NODE_VERSION: '18'
  PNPM_VERSION: '9'

jobs:
  # Pre-deployment checks
  pre-deploy:
    name: ğŸ” Pre-deployment Checks
    runs-on: ubuntu-latest
    
    outputs:
      should-deploy: ${{ steps.check.outputs.should-deploy }}
      commit-message: ${{ steps.commit.outputs.message }}
      
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2
          
      - name: ğŸ“ Get commit message
        id: commit
        run: |
          # Get commit message and properly escape it for GitHub Actions
          message=$(git log -1 --pretty=%B)
          
          # Use heredoc format for multiline output to avoid parsing issues
          {
            echo "message<<EOF"
            echo "$message"
            echo "EOF"
          } >> $GITHUB_OUTPUT
          
          # Display first line for logging (truncated if too long)
          first_line=$(echo "$message" | head -n1)
          if [ ${#first_line} -gt 100 ]; then
            echo "Commit message: ${first_line:0:100}..."
          else
            echo "Commit message: $first_line"
          fi
          
      - name: ğŸ” Check deployment conditions
        id: check
        run: |
          commit_message="${{ steps.commit.outputs.message }}"
          
          # Skip deployment if commit message contains [skip deploy]
          if [[ "$commit_message" == *"[skip deploy]"* ]]; then
            echo "should-deploy=false" >> $GITHUB_OUTPUT
            echo "â­ï¸ Deployment skipped due to [skip deploy] in commit message"
          else
            echo "should-deploy=true" >> $GITHUB_OUTPUT
            echo "âœ… Deployment conditions met"
          fi

  # Build for production
  build:
    name: ğŸ—ï¸ Production Build
    runs-on: ubuntu-latest
    needs: pre-deploy
    if: needs.pre-deploy.outputs.should-deploy == 'true'
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4
        
      - name: ğŸ“¦ Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}
          
      - name: ğŸŸ¢ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'
          
      - name: ğŸ“¥ Install dependencies
        run: |
          # Try frozen lockfile first, fallback to regular install if it fails
          pnpm install --frozen-lockfile || {
            echo "âš ï¸ Frozen lockfile failed, attempting regular install..."
            pnpm install --no-frozen-lockfile
          }
        
      - name: ğŸ§¹ Clean previous builds
        run: rm -rf dist
        
      - name: ğŸ—ï¸ Build for production
        run: pnpm run build
        env:
          NODE_ENV: production
          
      - name: ğŸ” Verify production build
        run: |
          echo "ğŸ” Verifying production build..."
          
          # Check required files exist
          required_files=(
            "dist/index.html"
            "dist/assets/style/styles.css"
            "dist/assets/js/script.js"
            "dist/site.webmanifest"
            "dist/robots.txt"
            "dist/sitemap.xml"
          )
          
          for file in "${required_files[@]}"; do
            if [ ! -f "$file" ]; then
              echo "âŒ Missing required file: $file"
              exit 1
            else
              echo "âœ… Found: $file"
            fi
          done
          
          # Check file sizes
          echo "ğŸ“Š Production build sizes:"
          find dist -type f -name "*.html" -o -name "*.css" -o -name "*.js" | while read file; do
            size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file")
            echo "  $(basename "$file"): ${size} bytes"
          done
          
      - name: ğŸ—œï¸ Optimize assets
        run: |
          # Additional optimization for production
          echo "ğŸ—œï¸ Running additional optimizations..."
          
          # Optimize images if imagemin is available
          if command -v imagemin &> /dev/null; then
            find dist -name "*.png" -o -name "*.jpg" -o -name "*.jpeg" | xargs imagemin --out-dir=dist/assets/img/
          fi
          
          # Generate integrity hashes for critical assets
          echo "ğŸ” Generating integrity hashes..."
          for file in dist/assets/style/styles.css dist/assets/js/script.js; do
            if [ -f "$file" ]; then
              hash=$(openssl dgst -sha384 -binary "$file" | openssl base64 -A)
              echo "Integrity hash for $file: sha384-$hash"
            fi
          done
          
      - name: ğŸ“¤ Upload production build
        uses: actions/upload-artifact@v4
        with:
          name: production-build
          path: dist/
          retention-days: 30

  # Deploy to Netlify
  deploy:
    name: ğŸŒ Deploy to Netlify
    runs-on: ubuntu-latest
    needs: [pre-deploy, build]
    if: needs.pre-deploy.outputs.should-deploy == 'true'
    environment: 
      name: ${{ github.event.inputs.environment || 'production' }}
      url: ${{ steps.deploy.outputs.url }}
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4
        
      - name: ğŸ“¥ Download production build
        uses: actions/download-artifact@v4
        with:
          name: production-build
          path: dist/
          
      - name: ğŸŒ Deploy to Netlify
        id: deploy
        uses: netlify/actions/cli@master
        with:
          args: deploy --prod --dir=dist --message="Deploy from GitHub Actions - ${{ needs.pre-deploy.outputs.commit-message }}"
        env:
          NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_AUTH_TOKEN }}
          NETLIFY_SITE_ID: ${{ secrets.NETLIFY_SITE_ID }}
          
      - name: ğŸ“ Get deployment URL
        run: |
          echo "ğŸŒ Deployment successful!"
          echo "URL: ${{ steps.deploy.outputs.url }}"
          
      - name: ğŸ”— Comment deployment URL
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            
            const botComment = comments.find(comment => 
              comment.user.type === 'Bot' && comment.body.includes('ğŸš€ Deployment Preview')
            );
            
            const commentBody = `ğŸš€ **Deployment Preview**
            
            âœ… Deploy successful! Preview your changes:
            ğŸ”— **Preview URL**: ${{ steps.deploy.outputs.url }}
            
            ğŸ“Š **Build Info**:
            - Commit: ${{ github.sha }}
            - Branch: ${{ github.head_ref }}
            - Workflow: ${{ github.run_id }}
            
            ---
            *This comment will be updated for each new deployment.*`;
            
            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: commentBody
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: commentBody
              });
            }

  # Post-deployment verification
  verify:
    name: âœ… Post-deployment Verification
    runs-on: ubuntu-latest
    needs: [pre-deploy, deploy]
    if: needs.pre-deploy.outputs.should-deploy == 'true'
    
    steps:
      - name: ğŸŸ¢ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          
      - name: ğŸ”§ Install verification tools
        run: |
          npm install -g lighthouse @lhci/cli puppeteer
          
      - name: ğŸŒ Wait for deployment to be ready
        run: |
          echo "â³ Waiting for deployment to be ready..."
          sleep 30
          
      - name: ğŸ” Verify deployment
        run: |
          # Get the site URL (you'll need to set this as a secret or environment variable)
          SITE_URL="${{ secrets.SITE_URL || 'https://yohann-hommet.netlify.app' }}"
          
          echo "ğŸ” Verifying deployment at: $SITE_URL"
          
          # Test if site is accessible
          response=$(curl -s -o /dev/null -w "%{http_code}" "$SITE_URL")
          if [ "$response" = "200" ]; then
            echo "âœ… Site is accessible (HTTP $response)"
          else
            echo "âŒ Site returned HTTP $response"
            exit 1
          fi
          
          # Test critical pages
          critical_paths=("/" "/offline.html")
          for path in "${critical_paths[@]}"; do
            url="$SITE_URL$path"
            response=$(curl -s -o /dev/null -w "%{http_code}" "$url")
            if [ "$response" = "200" ]; then
              echo "âœ… $url is accessible"
            else
              echo "âš ï¸ $url returned HTTP $response"
            fi
          done
          
      - name: ğŸš€ Quick Lighthouse audit
        run: |
          SITE_URL="${{ secrets.SITE_URL || 'https://yohann-hommet.netlify.app' }}"
          
          echo "ğŸš€ Running quick Lighthouse audit..."
          lhci autorun \
            --collect.url="$SITE_URL" \
            --collect.numberOfRuns=1 \
            --assert.preset=lighthouse:no-pwa \
            --upload.target=temporary-public-storage || echo "Lighthouse audit completed with warnings"
            
      - name: ğŸ”’ Security headers check
        run: |
          SITE_URL="${{ secrets.SITE_URL || 'https://yohann-hommet.netlify.app' }}"
          
          echo "ğŸ”’ Checking security headers..."
          
          # Check for important security headers
          headers_to_check=(
            "Content-Security-Policy"
            "X-Content-Type-Options"
            "X-Frame-Options"
            "X-XSS-Protection"
            "Referrer-Policy"
          )
          
          for header in "${headers_to_check[@]}"; do
            if curl -s -I "$SITE_URL" | grep -i "$header" > /dev/null; then
              echo "âœ… $header header is present"
            else
              echo "âš ï¸ $header header is missing"
            fi
          done
          
      - name: ğŸ“Š Performance check
        run: |
          SITE_URL="${{ secrets.SITE_URL || 'https://yohann-hommet.netlify.app' }}"
          
          echo "ğŸ“Š Running performance checks..."
          
          # Measure page load time
          load_time=$(curl -o /dev/null -s -w "%{time_total}" "$SITE_URL")
          echo "â±ï¸ Page load time: ${load_time}s"
          
          # Check if load time is reasonable (under 3 seconds)
          if (( $(echo "$load_time < 3.0" | bc -l) )); then
            echo "âœ… Page load time is acceptable"
          else
            echo "âš ï¸ Page load time is slow (>${load_time}s)"
          fi

  # Notify deployment status
  notify:
    name: ğŸ“¢ Deployment Notification
    runs-on: ubuntu-latest
    needs: [pre-deploy, deploy, verify]
    if: always() && needs.pre-deploy.outputs.should-deploy == 'true'
    
    steps:
      - name: ğŸ“¢ Deployment Success Notification
        if: needs.deploy.result == 'success' && needs.verify.result == 'success'
        run: |
          echo "ğŸ‰ Deployment completed successfully!"
          echo "âœ… Build: Success"
          echo "âœ… Deploy: Success" 
          echo "âœ… Verification: Success"
          
      - name: ğŸ“¢ Deployment Failure Notification
        if: needs.deploy.result == 'failure' || needs.verify.result == 'failure'
        run: |
          echo "âŒ Deployment failed!"
          echo "Build: ${{ needs.build.result }}"
          echo "Deploy: ${{ needs.deploy.result }}"
          echo "Verify: ${{ needs.verify.result }}"
          exit 1